<!doctype html><html lang=en><head><title>USB Audio Interface :: Don's Projects</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="For a long time I&rsquo;d wanted to make an audio interface for recording music and voice calls on my computer. It seemed like the ideal next step from making analog guitar effects pedals and some small microcontroller projects. I finally had the perfect opportunity in my last semester during the course CSE 145: Embedded Systems Design Project. The course is long over by the time I&rsquo;ve gotten around to writing this post, but I&rsquo;m happy to report that I still use this interface daily.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://dondrews.github.io/posts/audio-interface/><link rel=stylesheet href=https://dondrews.github.io/assets/style.css><link rel=apple-touch-icon href=https://dondrews.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://dondrews.github.io/img/favicon/orange.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="USB Audio Interface"><meta property="og:description" content="For a long time I&rsquo;d wanted to make an audio interface for recording music and voice calls on my computer. It seemed like the ideal next step from making analog guitar effects pedals and some small microcontroller projects. I finally had the perfect opportunity in my last semester during the course CSE 145: Embedded Systems Design Project. The course is long over by the time I&rsquo;ve gotten around to writing this post, but I&rsquo;m happy to report that I still use this interface daily.
"><meta property="og:url" content="https://dondrews.github.io/posts/audio-interface/"><meta property="og:site_name" content="Don's Projects"><meta property="og:image" content="https://dondrews.github.io/img/audio_interface/enclosure.jpg"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2023-10-08 00:00:00 +0000 UTC"></head><body class=orange><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Don's Projects</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About</a></li><li><a href=/posts>Blog - Tech</a></li><li><a href=/recipes>Recipes</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About</a></li><li><a href=/posts>Blog - Tech</a></li><li><a href=/recipes>Recipes</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://dondrews.github.io/posts/audio-interface/>USB Audio Interface</a></h1><div class=post-meta><span class=post-date>2023-10-08</span></div><img src=https://dondrews.github.io/img/audio_interface/enclosure.jpg class=post-cover alt="USB Audio Interface" title="Cover Image"><div class=table-of-contents><h2>Table of Contents</h2><nav id=TableOfContents><ul><li><a href=#background>Background</a><ul><li><a href=#difference-between-audio-sources>Difference between audio sources</a></li><li><a href=#usb-audio>USB Audio</a></li><li><a href=#analog-digital-conversion>Analog-Digital Conversion</a></li></ul></li><li><a href=#design>Design</a><ul><li><a href=#electrical>Electrical</a></li><li><a href=#firmware>Firmware</a></li><li><a href=#mechanical>Mechanical</a></li></ul></li><li><a href=#results>Results</a></li><li><a href=#future>Future</a></li></ul></nav></div><div class=post-content><div><p>For a long time I&rsquo;d wanted to make an audio interface for recording music and voice calls on my computer. It seemed like the ideal next step from making analog guitar effects pedals and some small microcontroller projects. I finally had the perfect opportunity in my last semester during the course <em>CSE 145: Embedded Systems Design Project</em>. The course is long over by the time I&rsquo;ve gotten around to writing this post, but I&rsquo;m happy to report that I still use this interface daily.</p><h2 id=background>Background<a href=#background class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The below sections detail some general information I gathered for this design. Hopefully it can be useful to others starting on audio electronics.</p><h3 id=difference-between-audio-sources>Difference between audio sources<a href=#difference-between-audio-sources class=hanchor arialabel=Anchor>&#8983;</a></h3><p>All analog audio sources function by oscillating a voltage or a current to represent sound. However, the specific differences between different types of sources requires consideration and in some cases special handling from the perspective of amplifier design. For the purposes of an audio interface, there are several categories which we are concerned with:</p><ul><li>Dynamic microphones</li><li>Condenser microphones</li><li>Pickup instruments</li><li>Line-level audio</li></ul><p>These can be grouped into the coarser categories of balanced and unbalanced audio, with the microphones generally being balanced, and the other two unbalanced. &ldquo;Balanced&rdquo; audio refers to the fact that these sources use cables in which both the negative and positive signal wires are near-identical in construction, with shielding connected to ground. This topology ensures that any interference along the cable length - either from capacitive coupling or EM sources - applies equally to both polarities. This &ldquo;common-mode&rdquo; interference can then be eliminated by a differential amplifier on the receiving end of the cable. The concept is well illustrated by the diagram from <a href=https://hackaday.com/2016/03/29/when-difference-matters/>Hackaday</a> below. On the other hand, unbalanced audio references the positive signal to ground, by connecting the shielding to the negative terminal on the source side, and to ground on the receiving side. The shielding still provides some resistance to interference, and these sources can be used with standard amplifiers. Microphones generally use balanced cables due to the low signal levels present on their output, though this is not as much of a concern for pickup instruments or line-level audio. The prototypical balanced cable for audio purposes is the XLR cable, which has three terminals for positive, negative, and ground.</p><p><img src=/img/audio_interface/diff4.webp alt="Differential signaling"></p><p>Dynamic microphones are a class of microphone that approximately functions as a speaker cone in reverse. There is a sealed diaphragm which is mechanically attached to an electromagnet. Changing pressure in the air causes the diaphragm to move, which then generates electric current by moving the electromagnet relative to a permanent magnet installed in the microphone. These sources have low sensitivity but also low impedance, on the order of 100 ohms. However, due to the inductive nature of the source, the preamplifier needs a comparatively large input impedance to avoid affecting the frequency response. These microphones have low sensitivity but are also inexpensive, making them very popular for recording instrument amplifiers and drums.</p><p>Condenser microphones function by a different mechanism. They form a capacitor from a thin metallic membrane and a stationary plate. Changing sound pressure causes this membrane to move, which alters the capacitance, generating a current. This topology is very high impedance, and also requires an external bias voltage to function, where 48 volts is the industry standard level. In order to lessen the difficulties with interfacing with high impedance sources, many condenser microphones contain an integrated FET for impedance matching, which is powered off the bias voltage. Condenser microphones are far more sensitive than dynamic microphones, and are common for recording voices. These are an extremely common type of microphone, but were not supported for this project due to the additional technical challenges associated with generating and exposing 48 volts.</p><p>Pickup instruments generate voltages based on the movements of metallic strings or tines next to an electromagnet, or from the compression of a piezoelectric material attached to a vibrating surface. Usually these transducers are referenced to ground, leading to an unbalanced audio source as discussed above. These sources are also low impedance, but must be matched with a high-impedance amplifier to preserve the frequency response. The standard connector for these types of sources is a 1/4" TS cable, and they are found in most electronic string instruments, and some drum microphones.</p><p>Lastly, line-level audio is an term which represents audio sources that are already amplified up to working voltages and currents. The range varies, but generally line-level sources have a maximum amplitude of approximately one volt. This is the easiest type of source to interface with, as no amplification or impedance matching is necessary before digitizing.</p><h3 id=usb-audio>USB Audio<a href=#usb-audio class=hanchor arialabel=Anchor>&#8983;</a></h3><p>One of the major advantages of USB is the device class system. This part of the specification defines a standard set of types of devices and their associated sub-protocols. For example, there are device classes for mass storage, human interface devices (such as mice and keyboards), printers, cameras, and hundreds of others. These classes cover the majority of use cases for USB. If a device is compliant with the device class specification, then it will generally work with any host operating system, making significantly less work for host driver implementers and device creators. This &ldquo;plug-and-play&rdquo; nature of USB devices is one of the major selling points of the standard, and has led to its wide adoption.</p><p>One of the device classes called USB Audio Device Class 2.0 (UAC) supports a wide variety of audio peripherals. By designing an audio interface to comply with this standard, no host drivers need to be written, and the device should seamlessly function with any host configuration.</p><p>There are several different transaction types defined in the USB standard: control, interrupt, isochronous, and bulk. Each transaction type is suited for a different use case, and isochronous transfers are specifically tailored for streaming applications. For the purposes of creating an audio interface, these and control transfers are the only necessary types. Isochronous endpoints are special in that they do not have any error checking or re-transmission in the protocol. This ensures the minimum latency possible, which is critically important for audio applications.</p><h3 id=analog-digital-conversion>Analog-Digital Conversion<a href=#analog-digital-conversion class=hanchor arialabel=Anchor>&#8983;</a></h3><p>The most important aspect of an audio interface is the conversion from analog to digital with the smallest amount of distortion or noise. Generally this is done using a discrete integrated circuit (IC) that continuously samples the analog lines and outputs digital representations. There are several architectures for ADCs, with the most common being successive approximation register (SAR) and delta-sigma. These two architectures have vastly different internal structures and methods of operation, the specifics of which are out of scope, but this <a href=https://www.analog.com/en/analog-dialogue/articles/the-right-adc-architecture.html>article</a> by Analog has some good info. It suffices to say that delta-sigma ADCs are more common for audio applications, because of higher bit resolutions and less stringent anti-aliasing requirements.</p><p>Irrespective of architecture, there are two primary design considerations for using ADCs. One is that ADCs generally have a low input impedance, and require a substantial amount of current from the previous analog stage. Even if the signal is already at the correct line level, a buffer is still required to drive the ADC inputs. The second is that high-frequency content will be aliased back into the frequency range of interest after digitization, usually appearing as noise. Therefore, it is important to have a low-pass anti-aliasing filter before signals enter the ADC. For audio purposes the range of interest is 20Hz to 20kHz, with a sampling frequency of 44.1 or 48kHz, so the -3dB point of the filter is usually placed between 20-40kHz.</p><h2 id=design>Design<a href=#design class=hanchor arialabel=Anchor>&#8983;</a></h2><p>The systems diagram below describes the amplifier stages and power tree based upon the above considerations. The external voltage rail is assumed to be noisy, and the negative rail will contain switching noise. Therefore both are isolated from the analog supply by an LDO (low-dropout linear regulator). The balanced XLR input has an additional difference amplifier to provide additional gain as well as eliminating the common-mode interference. Both channels pass through single-ended adjustable amplifiers, where external potentiometers adjust the gain. The summing amplifier adjusts the DC bias level to bring the full wavelength above zero volts, in order to bring the input to a safe level for the ADC. This ADC is attached to a USB-supporting microcontroller which passes the data to the host. The specific details of electrical, firmware, and mechanical design which enable this system are described in the following sections.</p><p><img src=/img/audio_interface/sys_diagram.png alt="System architecture of the audio interface"></p><h3 id=electrical>Electrical<a href=#electrical class=hanchor arialabel=Anchor>&#8983;</a></h3><p>The electrical design of this audio interface can be broken into three separate categories: analog, digital, and power. For analog, the primary considerations are providing enough gain, and reducing the amount of noise. The microphone used for testing this project was the <em>Shure SM57</em>, an extremely common and prototypical dynamic microphone. According to the specifications, this microphone has a sensitivity of 56mV/Pa. A more familiar metric would be that a standard speaking volume of 55dB SPL produces an output of 0.6mV. Therefore approximately 80dB of gain would be sufficient for the XLR signal path. This was split evenly across the differential and adjustable stages. For the instrument input, a unity gain is necessary to support line-level audio, and an electric guitar pickup produces approximately 100mVpp output. For consistency, both adjustable stages were designed for 40dB maximum gain and 0dB minimum gain.</p><p>In amplifier design, the intrinsic thermal noise generated by resistors can be a significant contributor to the overall noise profile. This thermal noise has a voltage that is linearly proportional to heat as well as resistance. Therefore, it is best practice to reduce the resistances used in the amplifier feedback loop and filters to the minimum level without loading the op-amps. This is especially important for the resistors in the difference amplifier, since the signal amplitudes are very low at this stage. The higher currents resulting from this choice have an additional noise benefit, as it reduces the effect of shot noise as well as capacitively or inductively coupled noise from the environment. The amplifiers were constructed with 4 <em>TI OPA2134</em> op-amps, which were chosen for low noise and high power supply rejection ratio (PSRR).</p><p>The digital design of the interface hinged on the choice of microcontroller and ADC. For the microcontroller, the <em>STM32F042</em> was chosen due to the hand-solderable package, USB support, and price. In addition this microcontroller had an I2S peripheral for interfacing with the ADC. The ADC chosen was the <em>TI PCM4202</em>, which provided two channels at 24 bits each, and a total harmonic distortion + noise (THD+N) of -105dB. This ADC is designed specifically for audio purposes, which brings several important features such as DC bias removal through an internal digital high-pass filter.</p><p>Delivering power to all these components required multiple different voltage rails. All op-amps were powered off the linearly regulated +7v and -7v rails, generated from low-noise LDOs. The negative voltage were generated by a switching regulator in Cuk configuration, again to reduce noise. The analog and digital 5v and 3.3v rails were both generated with higher-power LDOs. Usually a digital rail would be generated with another switching regulator, but a linear regulator was chosen to reduce to total amount of switching noise on the board, as well as reduce design complexity. In a future redesign I&rsquo;d like to power everything through USB, and in that case the higher efficiency of the swtiching regulator would trade more favorably.</p><p>The high-level layout of the printed circuit board (PCB) brought all connectors to the front edge to simplify mechanical design. In addition, digital and switching circuitry was spatially isolated from sensitive analog circuitry, as can be seen in the layout below. A significant number of test points and jumpers were added to aid testing and verification of the board after assembly.</p><p><img src=/img/audio_interface/layout.png alt="Layout of the PCB"></p><h3 id=firmware>Firmware<a href=#firmware class=hanchor arialabel=Anchor>&#8983;</a></h3><p>The <a href=https://github.com/DonDrews/audio_interface_cse145/blob/main/audio_usb_test/Core/Src/main.c>firmware</a> running on the microcontroller has 3 main tasks:</p><ul><li>Gather samples from the ADC, and move them into USB packets for transmission to the host.</li><li>Handle USB control and enumeration signals.</li><li>Control the clipping LEDs.</li></ul><p>The first of these tasks is accomplished through the use of the I2S peripheral and direct memory access module (DMA). The I2S peripheral generates control signals for the ADC and receives the samples in a bit-serial fashion. The DMA is then configured to move these samples into a circular buffer located in main memory upon each reception. This circular buffer is the hand-off point to the USB side of the firmware stack.</p><p>The <a href=https://docs.tinyusb.org/en/latest/>tinyUSB</a> library was used to implement most of the USB functionality. This is a middleware library that abstracts hardware-specific USB functionality into a generalized software API. USB device, configuration, and endpoint descriptors were created and made accessible to the host through tinyUSB. These allow the host to determine the name, manufacturer, device class, and specific audio attributes of the interface. Isochronous endpoint support in not included in the driver for stm32 in tinyUSB, so support for this endpoint and transfer type was added to a local fork of the library. I am hoping to upstream this change but have not found the time as of yet.</p><p>After each 1ms USB frame, the last millisecond of audio data is parsed in the circular buffer to determine if the clipping threshold has been exceeded, and to fix endianness issues created by the DMA copying. If the audio is clipping, the LED is turned on for the next 200ms to notify the user. This parsed data is then moved into a tinyUSB FIFO, where it is eventually placed into the stm32&rsquo;s packet buffer memory region. On the stm32 architecture, isochronous endpoints use double buffering to achieve maximum throughput for streaming applications such as audio.</p><h3 id=mechanical>Mechanical<a href=#mechanical class=hanchor arialabel=Anchor>&#8983;</a></h3><p>An enclosure for the PCB is essential to prevent both mechanical damage as well as ESD. The primary consideration in the mechanical layout was ease of assembly and disassembly. For this reason, all connectors are attached to only the front plate of the enclosure, so that the PCB can be entirely removed by only removing one face of the enclosure. In this same vein, the front and back plates are connected with M3 hex bolts to allow for many cycles of attachment and detachment without mechanical failure. For durability the sides of the enclosure are constructed with 1/4" oak boards, and the front and back plates with 1/8" brushed aluminum sheet metal. Both front and back plates were modeled in the CAD program <em>Fusion360</em> before being CNC routed and attached to the wooden side panels, as seen in the cover image.</p><p><img src=/img/audio_interface/cad.png alt="The CAD for the faceplate"></p><h2 id=results>Results<a href=#results class=hanchor arialabel=Anchor>&#8983;</a></h2><p>SNR measures the ratio of the difference in amplitude between the signal when at full scale, and the noise floor. It is a common way of measuring the amount of useful information that can be derived from a signal. Usually, the measurement is specified in dB and has an associated bandwidth over which the noise is collected. For audio, this band is assumed to be 20Hz-20kHz. However, this is a poor proxy for audio quality, as many other effects can lead to audible degradation, such as distortion. Total harmonic distortion (THD) is another measurement that quantifies the amount of distortion in a signal. The measurement is performed by inputting a sinusoid of a known frequency into a system, and then recording the output. Then, Fourier analysis is used to compare the power present in the fundamental frequency as opposed to the sum of all integer harmonics of that frequency. This is a very common measurement in power electronics, RF engineering, and amplifier design.</p><p>One of the most useful measurements of audio quality combines these two metrics into &ldquo;total harmonic distortion and noise&rdquo; or (THD + N). Sometimes it is also referred to in the inverse ratio form as &ldquo;signal to noise and distortion ratio&rdquo; (SINAD). This is performed by inputting a sinusoid into the system, and then applying a notch filter at that frequency to the output. The ratio between the total power in the unfiltered and filtered signals is the SINAD, and is a good proxy for the audible quality of the system. In order to provide a closer representation of perceptible audio quality, sometimes &ldquo;A-weighting&rdquo; is applied to the output, which scales the power at each frequency based on the perceived loudness by the human ear. Generally, this means attenuating the very high and very low frequencies, while amplifying the mid-range. For the purposes of this project, SINAD is used as the primary measurement of quality, but without A-weighting.</p><p>The audio interface was measured to have a SINAD of 45dB on the instrument channel and 27dB on the microphone channel. When viewing the frequency plot for the instrument input below, it can be seen that most of the SINAD reduction is due to the harmonic distortion and not the noise. These measurements fall short of the specification, and there are several theories as to the cause. One of the most likely candidates for the poor performance of the microphone input centers around the crosstalk between channels, which is approximately 30dB. When the instrument input is floating, the high impedance source amplifies EMI to nearly full-scale, and this carries over to the microphone input during testing. A fix was applied to resolve this issue, but additional testing did not take place after this change was made. Another possible cause for both channels is the mismatch between the real and expected ADC sampling frequency, which is 46.7kHz as opposed to 48kHz. This means the OS must pick up the slack of interpolating these samples, which could lead to all sorts of hidden issues.</p><p><img src=/img/audio_interface/dist.png alt="Measured spectrum of the tone"></p><h2 id=future>Future<a href=#future class=hanchor arialabel=Anchor>&#8983;</a></h2><p>This project went more seamlessly than I had expected, but there is still a lot I would like to improve on in a future revision. High on the list is adding support for condenser microphones, as they are the most commonly used for high-precision recordings. In the last year of use I have also noticed an occasional clicking noise, which I think can be attributed to the sampling rate issue above. Powering entirely off of the USB Vbus would also improve the usability significantly.</p><p>Here&rsquo;s a demo created by a good friend of mine who used the interface to record electric bass, drums, and Rhodes piano to demonstrate the audio quality. (We accidentally left the metronome in!)</p><figure><audio controls preload=metadata><source src=/demo.mp3 type=audio/mpeg></audio><figcaption>Demo (Vulfpeck - Beastly cover)</figcaption></figure></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://dondrews.github.io/posts/iterative-bvp-solvers-on-fpgas/><span class=button__text>Iterative BVP Solvers on FPGAs</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://dondrews.github.io/assets/main.js></script><script src=https://dondrews.github.io/assets/prism.js></script></div></body></html>