<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Don's Projects</title><link>https://dondrews.github.io/</link><description>Recent content on Don's Projects</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://dondrews.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Iterative BVP Solvers on FPGAs</title><link>https://dondrews.github.io/posts/iterative-bvp-solvers-on-fpgas/</link><pubDate>Wed, 01 Dec 2021 00:00:00 +0000</pubDate><guid>https://dondrews.github.io/posts/iterative-bvp-solvers-on-fpgas/</guid><description>For the course MATH179: Projects in Computational and Applied Mathematics at UCSD, I spent some time looking into accelerating ODE boundary value problem solvers on an FPGA. Unfortunately, this took place before I had learned of HLS, so it was written entirely in Verilog. I have slightly adapted my report for that course below to hopefully show some general practices about how FPGAs can be applied to HPC tasks. It is definitely worth noting that due to time constraints, this problem is very contrived, as linear ODE BVPs can be solved directly.</description><content>&lt;p>For the course MATH179: Projects in Computational and Applied Mathematics at UCSD, I spent some time looking into accelerating ODE boundary value problem solvers on an FPGA. Unfortunately, this took place before I had learned of HLS, so it was &lt;a href="https://github.com/DonDrews/de-on-fpga/tree/main/deon_fpga.srcs/sources_1/new">written entirely in Verilog.&lt;/a> I have slightly adapted my report for that course below to hopefully show some general practices about how FPGAs can be applied to HPC tasks. It is definitely worth noting that due to time constraints, this problem is very contrived, as linear ODE BVPs can be solved directly. However, the idea of using FPGAs for PDE BVPs with somewhat similar techniques is an active area of research.&lt;/p>
&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>The example problem in our implementation is the linear boundary value problem.&lt;/p>
&lt;p>$$\begin{cases} y&amp;rsquo;&amp;rsquo; - y = 0 \\ y(0)=1 \\ y(8)=0.5 \end{cases}$$&lt;/p>
&lt;p>This system can easily be solved analytically, and therefore is a good benchmark to verify the accuracy of our implementation. There are many ways in which to construct an iterative solver for this system. Due to the numerical instability inherent to the system as well as ease of development, we opted for a finite difference method for discretization followed by a basic Jacobi solver.&lt;/p>
&lt;p>The FDM is identical to the method presented in these &lt;a href="https://web.mit.edu/10.001/Web/Course_Notes/Differential_Equations_Notes/node9.html">course notes&lt;/a> which we will briefly outline. By taking the Taylor expansions of $y(t)$ and rearranging terms to approximate the second derivative we arrive at&lt;/p>
&lt;p>$$\frac{y(t + h) - 2y(t) + y(t - h)}{2h} - y(t) = 0$$&lt;/p>
&lt;p>When using a discretization such that $x_{i+1} - x_i = h$ this can be written&lt;/p>
&lt;p>$$\frac{y_{i+1} - 2y_i + y_{i-1}}{2h} - y_i = 0$$&lt;/p>
&lt;p>By combining these approximations to the system at each point in the domain together, we get a banded square matrix with as many columns and rows as there are points in the domain. This matrix also has only one non-zero entry on the diagonal in the first and last rows, to account for the boundary conditions. Constructing a Jacobi iteration scheme based on this matrix leads to the following equations&lt;/p>
&lt;p>$$\hat{y_{i}} = \begin{cases} 1 &amp;amp; i = 0 \\ (y_{i-1} + y_{i+1}) \times (2 + h^2)^{-1} &amp;amp; 0 &amp;lt; i &amp;lt; n \\ 0.5 &amp;amp; i = n \end{cases}$$&lt;/p>
&lt;p>Where $\hat{y}$ represents the next iteration&amp;rsquo;s approximation in the algorithm. Note that this computation requires only a single multiplication and addition per index per iteration, which lends well to FPGA implementation.&lt;/p>
&lt;h1 id="data-types-and-matlab-simulation">Data Types and MATLAB Simulation&lt;/h1>
&lt;p>Unlike traditional processors and GPUs where computations are most efficient when using the native bit-width of the system or floating point, FPGAs have much more flexibility to use smaller data types when this level of precision is not necessary. Using smaller data types leads to less area utilization and power usage. The relative lack of dedicated floating point hardware on FPGAs has also led to a wide adoption of fixed-point arithmetic for applications in DSP, control systems, and others. These fixed-point data types use a set amount of bits in the number for the integer portion, and the rest for the fractional part. For example, a common fixed-point data type used in FIR filters is &amp;ldquo;Q15&amp;rdquo;, which uses 16 bits to represent a signed number from -1 to 1 with an epsilon of $2^{-15}$.&lt;/p>
&lt;p>For the purposes of this linear solver, we simulated the algorithm in MATLAB using a variety of data types in order to determine the necessary precision for the algorithm to converge. What we found was that a Q4.12 fixed point representation was sufficiently precise for the algorithm to remain stable. The main bottleneck in this regard is the very small intermediary value in the calculation of the second derivative approximation as the number of points in the discretization increases.&lt;/p>
&lt;p>Additionally, in MATLAB we tested to see if the SOR algorithm could be utilized to improve on the convergence time of the Jacobi iteration. Unfortunately, the system is only slightly diagonally dominant, and SOR does not converge for any relaxation factor $\omega &amp;gt; 1$ in fixed point arithmetic.&lt;/p>
&lt;h1 id="system-architecture">System Architecture&lt;/h1>
&lt;p>&lt;img src="https://dondrews.github.io/img/fpga_sys_dia.png" alt="System Architecture Diagram">&lt;/p>
&lt;p>The general architecture for our implementation involves using the existing DSP resources on the FPGA and controlling them using logic in the fabric described with Verilog HDL. The data is sent and received from the interface computer using serial over USB. The current approximation is stored in a series of dual port block RAM resources. The current implementation for the example ODE involves a 128 point uniform discretization, with 16 points stored in each BRAM, and one DSP slice per BRAM. As shown in the above figure, each DSP slice is connected to the BRAM before and after it. This allows for sampling the indices just before and after the first and last index stored in the BRAM, which is necessary for the algorithm. It would be easy to scale this approach to much larger domains, the only limitation being the number of DSP slices, BRAMs, and the capacity of each BRAM.&lt;/p>
&lt;p>The goal of using multiple BRAMs is to overcome the main bottleneck on multicore processor setups: the DRAM bus bandwidth. While caching and other techniques have aided this issue in other computational problems, linear solvers generally are still limited by the number of reads per cycle. By using an FPGA we can read and write a very large number of data points per clock cycle, removing this bottleneck.&lt;/p>
&lt;p>Through the use of extensive pipelining, the task interval is shortened to only one cycle for computing a single new approximation value. Since all BRAM and DSP pairs can be operated in parallel, this leads to 24 cycles per iteration.&lt;/p>
&lt;h1 id="results">Results&lt;/h1>
&lt;p>&lt;img src="https://dondrews.github.io/img/fpga_plot.png" alt="Plot">&lt;/p>
&lt;p>Due to the fixed point arithmetic being used on the FPGA, we did not expect that the results would exactly match the analytical solution. For our purposes, we ran 5000 Jacobi iterations and compared the boundary value problem solution to a result computing in MATLAB.&lt;/p>
&lt;p>The computed solution of the FPGA is generally correct, but there is a large amount of error for $y$ close to $0$. We think this is because of the uneven rounding in the multiplication and addition. When multiple adjacent values of $y$ become $0$, this is a steady state for the algorithm since the next approximation is computed as a linear combination of its neighbors. This fact combined with rounding toward 0 in all cases is our hypothesis as to why this phenomenon occurs.&lt;/p>
&lt;p>Performance on the FPGA for domains this size is primarily limited by the slow serial communications between computer and FPGA used in our current implementation. However, in more advanced implementations with different hardware busses this is an easy limitation to overcome. Therefore we will focus on the computational speed only in our analysis. The FPGA we are currently testing on (a Xilinx Artix 7 on a Basys 3 development board) has a clock speed of 100MHz. Accounting for 24 clock cycles per iteration with 5000 iterations required, the full computation is completed in 1.2ms. Using the current design, the domain could be increased to 1280 points without any loss in speed by using more area. Further extensions of the domain would scale linearly from this point, until the BRAM capacity on the FPGA is reached.&lt;/p></content></item><item><title>USB Controller with STM32</title><link>https://dondrews.github.io/posts/usb-controller-with-stm32/</link><pubDate>Mon, 07 Dec 2020 00:00:00 +0000</pubDate><guid>https://dondrews.github.io/posts/usb-controller-with-stm32/</guid><description>Overview This project originally started nearly six years ago, when my friend and I patched together a prototype in my garage over the course of a week. It was constructed out of breadboard pushbuttons, birch plywood, an Arduino, and lots of glue. There were many issues with that version, including a patchwork driver, analog/digital interference, and unworkable wire management.
In 2020 we decided to revive the project, with the goal of fixing all the aforementioned issues, as well as providing a clean and ergonomic exterior.</description><content>&lt;h1 id="overview">Overview&lt;/h1>
&lt;p>This project originally started nearly six years ago, when my friend and I patched together a prototype in my garage over the course of a week. It was constructed out of breadboard pushbuttons, birch plywood, an Arduino, and lots of glue. There were many issues with that version, including a patchwork driver, analog/digital interference, and unworkable wire management.&lt;/p>
&lt;p>In 2020 we decided to revive the project, with the goal of fixing all the aforementioned issues, as well as providing a clean and ergonomic exterior. The goal was to have a generalized controller/gamepad for use with computer games. This time, we were able to succeed in that pursuit. Below I will elaborate on our design process.&lt;/p>
&lt;h1 id="firmware">Firmware&lt;/h1>
&lt;p>&lt;a href="https://github.com/DonDrews/MOBAC2">GitHub Repo&lt;/a>&lt;/p>
&lt;p>One of the main goals was to have the controller be portable and simple to use. To that end, we decided to make a standard USB HID (Human Interface Device). This would allow it to be plugged into any computer and used without driver installations or custom programs, just like a standard USB keyboard or mouse. In fact, the controller enumerates as both a keyboard and a mouse on startup, and provides mouse input through the joystick, and keyboard input through the buttons. While this is a fairly simple paradigm, there were a few intricacies.&lt;/p>
&lt;p>One of the main downsides to a naive implementation of the joystick-to-mouse mapping is that different uses require different schemes. In some cases, moving the pointer based on the direction of the joystick is the most natural. In others, having the pointer locked to the position of the joystick is best. The USB HID standard refers to these as &amp;ldquo;relative&amp;rdquo; and &amp;ldquo;absolute&amp;rdquo; positioning respectively. Unfortunately, this property is stored in the device descriptor, and is therefore static between enumerations. To circumvent this, our controller is always in absolute mode, but can emulate relative movement based on a toggle switch.&lt;/p>
&lt;p>After writing the device descriptor, I implemented the USB functionality using the ST-provided middleware. Interfacing with the hardware was simple, and was just a matter of reading GPIOs and setting up the internal ADC channels for the joystick. Outside of one difficult-to-trace polling interval bug, the development process thankfully had few hiccups.&lt;/p>
&lt;h1 id="electrical">Electrical&lt;/h1>
&lt;p>&lt;img src="https://dondrews.github.io/img/controller-wiring.jpg" alt="Controller Wiring">&lt;/p>
&lt;p>At the heart of the controller is an stm32f042k6t6 microcontroller on a Nucleo development board. It was chosen for its low price, USB support, small form-factor and sufficient GPIO. Few micros seemed to fit these criterion, but the Nucleo ended up working out nicely. One oversight was that not all GPIO are usable in the default configuration, as some are tied to other functions such as the FTDI communication with the host computer. However, by desoldering a few 0603 jumpers, this was resolved.&lt;/p>
&lt;p>As with any physical switch interface, debouncing is required. Testing with an oscilloscope revealed that the maximum bounce time for these buttons was about 2ms. We decided that, given the amount of buttons, implementing this in software was the best choice. Power for the controller is provided by the USB 5v connection, which is stepped down by an onboard 3.3v regulator.&lt;/p>
&lt;h1 id="contruction">Contruction&lt;/h1>
&lt;p>To avoid the mess of last time, we opted to 3d print all of the shell-pieces for the controller. My friend first carved controllers into Styrofoam blocks to model the ergonomics and button placement, and then measured the dimensions and modeled in CAD. It took a few revisions to work out the kinks, but the final shell is reasonably comfortable and sturdy. A few last-minute edits were made with a hacksaw.&lt;/p>
&lt;p>&lt;img src="https://dondrews.github.io/img/controller-cad.png" alt="Controller CAD">&lt;/p>
&lt;p>After cleaning out the supports and accumulating all the necessary parts, actual construction only took one day to complete. The joystick was soldered to a protoboard, which was epoxied to the shell with a slab of birch plywood. This protoboard was also used for interfacing grounding and power. All of the connections to the microcontroller had female breadboard headers attached, to allow for modifications in the future. After all the connections were soldered, and the wires were squeezed into the shell and taped up, we were happy to find that the joystick and most of the buttons functioned as expected. The remaining buttons were fixed the following week.&lt;/p>
&lt;p>&lt;img src="https://dondrews.github.io/img/controller-print.png" alt="Controller Print">&lt;/p>
&lt;h1 id="conclusion">Conclusion&lt;/h1>
&lt;p>While the controller isn&amp;rsquo;t quite as easy to use as we were hoping, it does function as a working USB controller. In addition, it is on a much stronger technological footing than the previous attempt. We will probably take a break from this project for a while, but in the future we hope to make more controllers with displays, dedicated PCBs, and sleeker ergonomics.&lt;/p></content></item><item><title>Raspberry Pi LCD Kernel Driver</title><link>https://dondrews.github.io/posts/raspberry-pi-lcd-kernel-driver/</link><pubDate>Sat, 14 Nov 2020 00:00:00 +0000</pubDate><guid>https://dondrews.github.io/posts/raspberry-pi-lcd-kernel-driver/</guid><description>Just to preface, this was done as an educational exercise. There are great existing user space libraries for interfacing with the well-loved st7036 chipset. However, I thought it would be an interesting challenge to write a kernel module for raspberry pi that implemented a character device driver at the register level. Previously, I wrote a driver for this display for stm32, so my goal was to focus on the kernel aspects rather than the interface, which I copied with few changes.</description><content>&lt;p>Just to preface, this was done as an educational exercise. There are great existing user space libraries for interfacing with the well-loved st7036 chipset. However, I thought it would be an interesting challenge to write a kernel module for raspberry pi that implemented a character device driver at the register level. Previously, I wrote a driver for this display for stm32, so my goal was to focus on the kernel aspects rather than the interface, which I copied with few changes.&lt;/p>
&lt;p>This project, like many others, involved more reading than coding or building. Thankfully, there was great information to be found online, in places such as the &lt;a href="https://lwn.net/Kernel/LDD3/">Linux Device Drivers book&lt;/a> and the &lt;a href="https://www.raspberrypi.org/app/uploads/2012/02/BCM2835-ARM-Peripherals.pdf">Broadcom peripherals datasheet&lt;/a>. There were a few topics that were not well documented, such as the creation of /dev entries and which of the several delay functions to use for a given scenario, but after some searching I found answers to these as well. As for the driver itself, it has a fairly standard topology. On module initialization, a virtual memory page for the GPIO registers is mapped, and startup commands are sent to the screen. Since Raspbian supports it, udev is utilized to create the /dev entry for the character device. Reads simply return a static message, and writes are sent over the bus to the screen one nibble at a time. While the operations in this driver are basic, I think it was a good starting place for kernel-side development. I hope to work on a network or block device driver, and utilize more advanced features in the future. The code for this driver is &lt;a href="https://github.com/DonDrews/linux_driver_tests">here&lt;/a>. Included in the repository is a small script to write to the screen from stdin.&lt;/p></content></item><item><title>Remote Control Car</title><link>https://dondrews.github.io/posts/remote-control-car/</link><pubDate>Mon, 03 Aug 2020 00:00:00 +0000</pubDate><guid>https://dondrews.github.io/posts/remote-control-car/</guid><description>The goal of this project was to create a small and simple RC car using only materials that were on hand. While most RC devices are operated off a radio transmitter and receiver running directly into a motor controller, I opted for a more standard robotics approach of using an on-board computer (specifically a Raspberry Pi 2). This would then have a Wi-Fi dongle where it can communicate with a controlling computer with a gamepad for driving controls.</description><content>&lt;p>The goal of this project was to create a small and simple RC car using only materials that were on hand. While most RC devices are operated off a radio transmitter and receiver running directly into a motor controller, I opted for a more standard robotics approach of using an on-board computer (specifically a Raspberry Pi 2). This would then have a Wi-Fi dongle where it can communicate with a controlling computer with a gamepad for driving controls. Having an OBC also makes running a video feed significantly easier.&lt;/p>
&lt;p>The first step was to assemble the mechanical side of the car. I did not have any motors on hand, but luckily an old, broken stereo had a CD read head with a sufficiently powerful motor and gearing. Bending and cutting this read head assembly, and adding a wire coat hanger as an axle, provided a workable drive assembly.&lt;/p>
&lt;p>&lt;img src="https://dondrews.github.io/img/gearbox.jpg" alt="Gearbox of the RC car">&lt;/p>
&lt;p>As seen in the title image, I cut some wooden wheels out of plywood and attached a servo motor with the front axle. Lots of the work could have been cleaner, but it is a functional base for adding tech on top.&lt;/p>
&lt;p>Moving onto the electrical side, the Raspberry Pi GPIO cannot source enough current to power the motor nor the servo. Therefore, a power board is required to control these peripherals. The only power source I have on hand is 9 volt batteries, but the motor and the servo both require 5 volts to operate within specification. Thankfully, I had a single L7805 linear regulator around to use for this conversion. A linear regulator is not the ideal choice for this application, but it would be functional with enough cooling.&lt;/p>
&lt;p>&lt;img src="https://dondrews.github.io/img/rc-car-schematic.png" alt="Schematic of the RC car">&lt;/p>
&lt;p>The above schematic is, to my knowledge, a commonplace implementation of this scheme. The motors are controlled through an H-bridge, using the body diodes of the MOSFETs to handle inductive flyback. The 3.3v logic level of the Raspberry Pi is not sufficient to put the FETs into full conduction, so two inverting NPN switches are used in series for each input (a single FET each would have been better, but I didn&amp;rsquo;t have any extras). The 5v power rail has two smoothing capacitors to handle low and high frequency ripple along with an LED to indicate power. The servo is connected to the 5v rail and a Raspberry Pi pin. Lastly an indicator LED is in place, that I&amp;rsquo;ll likely use to show Wi-Fi connection in the future. The design was first tested on a breadboard, and later moved to a perfboard. In order to control heat dissipation from the regulator, part of an old GPU heatsink was cut off and attached.&lt;/p>
&lt;p>&lt;img src="https://dondrews.github.io/img/heatsink.jpg" alt="Heatsink jankily attached to this LDO">&lt;/p>
&lt;p>As with anything electrical, I always fear some oversight or edge case not considered, but this board seems to be functional for the time being. Once I learn more about electronics, I may change the design entirely.&lt;/p>
&lt;p>The last part I implemented was the &lt;a href="https://github.com/DonDrews/rc-car-control">software&lt;/a>. It seemed that just some simple python scripts should be up to the task. I attached an unused Logitech C720 webcam to one of the host USB ports on the Pi. Using OpenCV, images are captured from the camera, resized to 480p, and encoded into a JPEG format. A TCP connection is established with the control computer using python sockets, and each image is sent independently over this link. On the control side, the images are decoded and displayed. The latency of this setup is suboptimal - around 250ms - due to both the inherent latency of the C720 and the time taken to encode each image (about 70ms). Certainly gains could be had by using GPU image compression, or even a dedicated video format like H.264. However, in this situation I felt that the current setup provided adequate performance to make the additional complexity not worthwhile.&lt;/p>
&lt;p>In another python thread, the control computer receives events from a USB gamepad and translates them into power and steering values before sending them over the same TCP port to the on board computer. Originally I used the gpiozero library for outputting the PWM signals, but realized that this did not take advantage of the existing PWM hardware and used a software emulation instead. An oscilloscope revealed that the accuracy of the pulse widths was inadequate, especially on the servo line. After some searching, I switched to the pigpio library which allows use of the hardware PWM, and the issue was resolved.&lt;/p>
&lt;p>After the mechanical, electrical, and software components were completed, I realized that I did not have a Wi-Fi dongle and that the servo I had installed was broken. Originally I had also planned to power the Raspberry Pi from the power board, but the L7805 was unable to supply enough stable current for reliable operation. A cellphone &amp;ldquo;power bank&amp;rdquo; was able to fix this issue, but overall the car was not able to be completed due to the other issues. Below is the current state of the car; it has the motor control and video feed operational.&lt;/p>
&lt;p>&lt;img src="https://dondrews.github.io/img/rc-full-layout.jpg" alt="The full electrical of the rc car on a table">&lt;/p>
&lt;p>Hopefully in the future I can obtain these last two parts and install all the boards onto the chassis. For the time being, the project is a proof of concept with most of the desired functionality. When the project is completed, this post will be updated.&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;!-- raw HTML omitted -->&lt;/p></content></item><item><title>About</title><link>https://dondrews.github.io/about/</link><pubDate>Sat, 27 Jun 2020 00:00:00 +0000</pubDate><guid>https://dondrews.github.io/about/</guid><description>Welcome! I am Donovan Drews, and this is my technical blog of various projects I dabble with on my spare time. Currently I work as an FPGA engineer, and previously I studied mathematics at UC San Diego. The topics contained here range from embedded systems to audio electronics to software and visualizations. If you have any questions you can reach me at donovancarldrews@gmail.com.
GitHub
LinkedIn</description><content>&lt;p>Welcome! I am Donovan Drews, and this is my technical blog of various projects I dabble with on my spare time. Currently I work as an FPGA engineer, and previously I studied mathematics at UC San Diego. The topics contained here range from embedded systems to audio electronics to software and visualizations. If you have any questions you can reach me at &lt;a href="mailto:donovancarldrews@gmail.com">donovancarldrews@gmail.com&lt;/a>.&lt;/p>
&lt;p>&lt;a href="https://github.com/DonDrews">GitHub&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.linkedin.com/in/donovan-d-b05237132/">LinkedIn&lt;/a>&lt;/p></content></item><item><title>Interactive Math Webpage</title><link>https://dondrews.github.io/posts/interactive-math-webpage/</link><pubDate>Sat, 27 Jun 2020 00:00:00 +0000</pubDate><guid>https://dondrews.github.io/posts/interactive-math-webpage/</guid><description>I&amp;rsquo;ve always been interested in visual descriptions of math, and I think interactive displays are a useful educative tool for developing intuition. Making a website to visually display the terms of the complex exponential function (as a Maclaurin series) has been on the to-do list for a while. Problem is, I am not a web developer, and have never worked with web technologies.
I had a few days open so I decided to dig into the details and make this webpage.</description><content>&lt;p>I&amp;rsquo;ve always been interested in visual descriptions of math, and I think interactive displays are a useful educative tool for developing intuition. Making a website to visually display the terms of the complex exponential function (as a Maclaurin series) has been on the to-do list for a while. Problem is, I am not a web developer, and have never worked with web technologies.&lt;/p>
&lt;p>I had a few days open so I decided to dig into the details and make this webpage. I think my inexperience with JS, HTML, and CSS show through but overall I am happy with the result. If I have any more ideas for these sorts of webpages I might continue them as a series in the future.&lt;/p>
&lt;p>&lt;a href="https://dondrews.github.io/complex-exponential/">Website&lt;/a>&lt;/p></content></item></channel></rss>